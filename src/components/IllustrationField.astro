---
/**
 * IllustrationField Component
 * 
 * Creates a scattered field of illustrations with subtle drift animations.
 * Uses CSS Grid with random transforms for pseudo-random positioning.
 * When real illustration ids are provided and files exist in public/illustrations/,
 * those slots show the generated images; otherwise placeholders (colored shapes) are used.
 * 
 * Variants:
 * - hero: Large, sparse field for the homepage hero section
 * - dense: Tighter grid with more objects for visual richness
 * - minimal: Few objects, subtle positioning
 */

import fs from 'node:fs';
import path from 'node:path';

interface Props {
  variant?: 'hero' | 'dense' | 'minimal';
  class?: string;
  /** Optional list of illustration ids (e.g. ['bear']) — if file exists, shown in the field */
  realIllustrationIds?: string[];
}

const { variant = 'hero', class: className = '', realIllustrationIds = [] } = Astro.props;

const projectRoot = process.cwd();
const illustrationsDir = path.join(projectRoot, 'public', 'illustrations');

/** Check which real illustration files exist (png or svg); returns id -> true for existing */
const existingRealIds = new Set(
  realIllustrationIds.filter((id) => {
    const png = path.join(illustrationsDir, `${id}.png`);
    const svg = path.join(illustrationsDir, `${id}.svg`);
    return fs.existsSync(png) || fs.existsSync(svg);
  })
);

/** Get file extension for an illustration id (prefer png) */
function getIllustrationExt(id) {
  const png = path.join(illustrationsDir, `${id}.png`);
  return fs.existsSync(png) ? 'png' : 'svg';
}

// Placeholder illustrations until we generate real ones
// These use simple SVG shapes in our color palette
const placeholderIllustrations = [
  { id: 'circle-1', color: '#FF9B9B', shape: 'circle' },
  { id: 'circle-2', color: '#A8D5BA', shape: 'circle' },
  { id: 'circle-3', color: '#FFE5A3', shape: 'circle' },
  { id: 'square-1', color: '#B5D8EB', shape: 'square' },
  { id: 'square-2', color: '#E8C5E5', shape: 'square' },
  { id: 'circle-4', color: '#FFD4A3', shape: 'circle' },
  { id: 'circle-5', color: '#C5E8E0', shape: 'circle' },
  { id: 'square-3', color: '#FFB5B5', shape: 'square' },
  { id: 'circle-6', color: '#D5C8E8', shape: 'circle' },
  { id: 'circle-7', color: '#B8E0D2', shape: 'circle' },
  { id: 'square-4', color: '#F5D5C8', shape: 'square' },
  { id: 'circle-8', color: '#C8E0F5', shape: 'circle' },
];

// Pre-defined positions for predictable, harmonious layout
// Each position is [x%, y%, rotation, scale, animationClass]
const heroPositions = [
  [5, 15, -8, 0.8, 'animate-drift'],
  [15, 75, 5, 0.6, 'animate-drift-alt'],
  [25, 25, -3, 0.9, 'animate-drift-slow'],
  [35, 85, 8, 0.7, 'animate-drift'],
  [55, 10, -5, 0.75, 'animate-drift-alt'],
  [65, 70, 3, 0.85, 'animate-drift-slow'],
  [75, 35, -10, 0.65, 'animate-drift'],
  [85, 80, 6, 0.9, 'animate-drift-alt'],
  [90, 20, -4, 0.7, 'animate-drift-slow'],
  [45, 60, 7, 0.55, 'animate-drift'],
  [10, 45, -6, 0.6, 'animate-drift-alt'],
  [80, 55, 4, 0.75, 'animate-drift-slow'],
];

const densePositions = [
  ...heroPositions,
  [20, 50, 4, 0.5, 'animate-drift'],
  [40, 30, -7, 0.6, 'animate-drift-alt'],
  [60, 45, 5, 0.55, 'animate-drift-slow'],
  [30, 65, -4, 0.65, 'animate-drift'],
  [70, 25, 8, 0.5, 'animate-drift-alt'],
  [50, 80, -6, 0.7, 'animate-drift-slow'],
];

const minimalPositions = [
  [10, 20, -5, 0.7, 'animate-drift'],
  [85, 30, 5, 0.8, 'animate-drift-alt'],
  [20, 75, 3, 0.65, 'animate-drift-slow'],
  [75, 70, -4, 0.75, 'animate-drift'],
];

const positions = variant === 'dense' ? densePositions : variant === 'minimal' ? minimalPositions : heroPositions;

// Real illustration slot: index 4 = upper-mid hero (55% from left, 10% from top) — visible but not on top of headline
const realIdList = realIllustrationIds.filter((id) => existingRealIds.has(id));
const realImageSlotIndex = 4;
const selectedIllustrations = positions.map((pos, i) => {
  const placeholder = placeholderIllustrations[i % placeholderIllustrations.length];
  const realId = i === realImageSlotIndex && realIdList[0] ? realIdList[0] : null;
  return {
    ...placeholder,
    position: pos,
    realId,
  };
});
---

<!-- Bear (or other real illustration) appears at slot index 4: ~55% from left, ~10% from top of hero. On viewports ≤480px only the real illustration is shown. -->
<div class:list={["illustration-field", `illustration-field--${variant}`, className]} aria-hidden="true" data-real-illustration-slot="4">
  {selectedIllustrations.map(({ id, color, shape, position, realId }) => {
    const [x, y, rotation, scale, animClass] = position;
    const size = shape === 'circle' ? 40 + (realId ? 20 : Math.random() * 30) : 30 + (realId ? 15 : Math.random() * 25);
    const displaySize = realId ? 88 : size;
    
    return (
      <div 
        class={`illustration-item ${animClass} ${realId ? 'illustration-item--real' : 'illustration-item--placeholder'}`}
        style={`
          left: ${x}%;
          top: ${y}%;
          transform: rotate(${rotation}deg) scale(${scale});
          animation-delay: ${Math.random() * 5}s;
        `}
      >
        {realId ? (
          <img
            src={`/illustrations/${realId}.${getIllustrationExt(realId)}`}
            alt="Decorative illustration"
            title={realId === 'bear' ? 'Bear (fallback illustration)' : undefined}
            width={displaySize}
            height={displaySize}
            loading="lazy"
            decoding="async"
            class="illustration-item__img"
          />
        ) : shape === 'circle' ? (
          <svg width={size} height={size} viewBox="0 0 40 40">
            <circle cx="20" cy="20" r="18" fill={color} />
          </svg>
        ) : (
          <svg width={size} height={size} viewBox="0 0 40 40">
            <rect x="4" y="4" width="32" height="32" rx="8" fill={color} />
          </svg>
        )}
      </div>
    );
  })}
</div>

<style>
  .illustration-field {
    position: absolute;
    inset: 0;
    overflow: hidden;
    pointer-events: none;
    z-index: 0;
  }
  
  .illustration-item {
    position: absolute;
    opacity: 0.6;
    transition: opacity 0.3s ease;
  }
  
  .illustration-field--hero .illustration-item {
    opacity: 0.5;
  }
  
  .illustration-field--dense .illustration-item {
    opacity: 0.4;
  }
  
  .illustration-field--minimal .illustration-item {
    opacity: 0.6;
  }
  
  .illustration-item__img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }
  
  .illustration-item--real {
    opacity: 0.85;
  }
  
  /* Subtle hover effect on parent container */
  .illustration-field:hover .illustration-item {
    opacity: 0.7;
  }
  
  /* Import motion styles for animations */
  .animate-drift {
    animation: drift 15s ease-in-out infinite;
  }
  
  .animate-drift-alt {
    animation: drift-alt 18s ease-in-out infinite;
  }
  
  .animate-drift-slow {
    animation: drift 22s ease-in-out infinite;
  }
  
  @keyframes drift {
    0%, 100% {
      transform: translate(0, 0) rotate(var(--rotation, 0deg));
    }
    25% {
      transform: translate(2px, -3px) rotate(calc(var(--rotation, 0deg) + 0.5deg));
    }
    50% {
      transform: translate(3px, -5px) rotate(calc(var(--rotation, 0deg) + 1deg));
    }
    75% {
      transform: translate(1px, -2px) rotate(calc(var(--rotation, 0deg) + 0.3deg));
    }
  }
  
  @keyframes drift-alt {
    0%, 100% {
      transform: translate(0, 0) rotate(var(--rotation, 0deg));
    }
    25% {
      transform: translate(-2px, 2px) rotate(calc(var(--rotation, 0deg) - 0.5deg));
    }
    50% {
      transform: translate(-4px, 4px) rotate(calc(var(--rotation, 0deg) - 1deg));
    }
    75% {
      transform: translate(-1px, 1px) rotate(calc(var(--rotation, 0deg) - 0.3deg));
    }
  }
  
  @media (prefers-reduced-motion: reduce) {
    .illustration-item {
      animation: none !important;
    }
  }
  
  /* On small screens hide only placeholders so the real illustration (e.g. bear) stays visible */
  @media (max-width: 480px) {
    .illustration-field--hero .illustration-item--placeholder {
      display: none;
    }
  }
</style>
